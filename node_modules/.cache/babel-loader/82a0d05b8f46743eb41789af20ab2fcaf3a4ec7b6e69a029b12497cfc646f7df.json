{"ast":null,"code":"'use strict';\n\nvar bindexOf = require('buffer-indexof');\nvar equalSign = new Buffer('=');\nmodule.exports = function (opts) {\n  var binary = opts ? opts.binary : false;\n  var that = {};\n  that.encode = function (data, buf, offset) {\n    if (!data) data = {};\n    if (!offset) offset = 0;\n    if (!buf) buf = new Buffer(that.encodingLength(data) + offset);\n    var oldOffset = offset;\n    var keys = Object.keys(data);\n    if (keys.length === 0) {\n      buf[offset] = 0;\n      offset++;\n    }\n    keys.forEach(function (key) {\n      var val = data[key];\n      var oldOffset = offset;\n      offset++;\n      if (val === true) {\n        offset += buf.write(key, offset);\n      } else if (Buffer.isBuffer(val)) {\n        offset += buf.write(key + '=', offset);\n        var len = val.length;\n        val.copy(buf, offset, 0, len);\n        offset += len;\n      } else {\n        offset += buf.write(key + '=' + val, offset);\n      }\n      buf[oldOffset] = offset - oldOffset - 1;\n    });\n    that.encode.bytes = offset - oldOffset;\n    return buf;\n  };\n  that.decode = function (buf, offset, len) {\n    if (!offset) offset = 0;\n    if (!Number.isFinite(len)) len = buf.length;\n    var data = {};\n    var oldOffset = offset;\n    while (offset < len) {\n      var b = decodeBlock(buf, offset);\n      var i = bindexOf(b, equalSign);\n      offset += decodeBlock.bytes;\n      if (b.length === 0) continue; // ignore: most likely a single zero byte\n      if (i === -1) data[b.toString().toLowerCase()] = true;else if (i === 0) continue; // ignore: invalid key-length\n      else {\n        var key = b.slice(0, i).toString().toLowerCase();\n        if (key in data) continue; // ignore: overwriting not allowed\n        data[key] = binary ? b.slice(i + 1) : b.slice(i + 1).toString();\n      }\n    }\n    that.decode.bytes = offset - oldOffset;\n    return data;\n  };\n  that.encodingLength = function (data) {\n    if (!data) return 1; // 1 byte (single empty byte)\n    var keys = Object.keys(data);\n    if (keys.length === 0) return 1; // 1 byte (single empty byte)\n    return keys.reduce(function (total, key) {\n      var val = data[key];\n      total += Buffer.byteLength(key) + 1; // +1 byte to store field length\n      if (Buffer.isBuffer(val)) total += val.length + 1; // +1 byte to fit equal sign\n      else if (val !== true) total += Buffer.byteLength(String(val)) + 1; // +1 byte to fit equal sign\n      return total;\n    }, 0);\n  };\n  return that;\n};\nfunction decodeBlock(buf, offset) {\n  var len = buf[offset];\n  var to = offset + 1 + len;\n  var b = buf.slice(offset + 1, to > buf.length ? buf.length : to);\n  decodeBlock.bytes = len + 1;\n  return b;\n}","map":{"version":3,"names":["bindexOf","require","equalSign","Buffer","module","exports","opts","binary","that","encode","data","buf","offset","encodingLength","oldOffset","keys","Object","length","forEach","key","val","write","isBuffer","len","copy","bytes","decode","Number","isFinite","b","decodeBlock","i","toString","toLowerCase","slice","reduce","total","byteLength","String","to"],"sources":["C:/Users/park0/Desktop/miniGamesProject/mgp-app/node_modules/dns-txt/index.js"],"sourcesContent":["'use strict'\n\nvar bindexOf = require('buffer-indexof')\n\nvar equalSign = new Buffer('=')\n\nmodule.exports = function (opts) {\n  var binary = opts ? opts.binary : false\n  var that = {}\n\n  that.encode = function (data, buf, offset) {\n    if (!data) data = {}\n    if (!offset) offset = 0\n    if (!buf) buf = new Buffer(that.encodingLength(data) + offset)\n\n    var oldOffset = offset\n    var keys = Object.keys(data)\n\n    if (keys.length === 0) {\n      buf[offset] = 0\n      offset++\n    }\n\n    keys.forEach(function (key) {\n      var val = data[key]\n      var oldOffset = offset\n      offset++\n\n      if (val === true) {\n        offset += buf.write(key, offset)\n      } else if (Buffer.isBuffer(val)) {\n        offset += buf.write(key + '=', offset)\n        var len = val.length\n        val.copy(buf, offset, 0, len)\n        offset += len\n      } else {\n        offset += buf.write(key + '=' + val, offset)\n      }\n\n      buf[oldOffset] = offset - oldOffset - 1\n    })\n\n    that.encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  that.decode = function (buf, offset, len) {\n    if (!offset) offset = 0\n    if (!Number.isFinite(len)) len = buf.length\n    var data = {}\n    var oldOffset = offset\n\n    while (offset < len) {\n      var b = decodeBlock(buf, offset)\n      var i = bindexOf(b, equalSign)\n      offset += decodeBlock.bytes\n\n      if (b.length === 0) continue // ignore: most likely a single zero byte\n      if (i === -1) data[b.toString().toLowerCase()] = true\n      else if (i === 0) continue // ignore: invalid key-length\n      else {\n        var key = b.slice(0, i).toString().toLowerCase()\n        if (key in data) continue // ignore: overwriting not allowed\n        data[key] = binary ? b.slice(i + 1) : b.slice(i + 1).toString()\n      }\n    }\n\n    that.decode.bytes = offset - oldOffset\n    return data\n  }\n\n  that.encodingLength = function (data) {\n    if (!data) return 1 // 1 byte (single empty byte)\n    var keys = Object.keys(data)\n    if (keys.length === 0) return 1 // 1 byte (single empty byte)\n    return keys.reduce(function (total, key) {\n      var val = data[key]\n      total += Buffer.byteLength(key) + 1 // +1 byte to store field length\n      if (Buffer.isBuffer(val)) total += val.length + 1 // +1 byte to fit equal sign\n      else if (val !== true) total += Buffer.byteLength(String(val)) + 1 // +1 byte to fit equal sign\n      return total\n    }, 0)\n  }\n\n  return that\n}\n\nfunction decodeBlock (buf, offset) {\n  var len = buf[offset]\n  var to = offset + 1 + len\n  var b = buf.slice(offset + 1, to > buf.length ? buf.length : to)\n  decodeBlock.bytes = len + 1\n  return b\n}\n"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,QAAQ,GAAGC,OAAO,CAAC,gBAAgB,CAAC;AAExC,IAAIC,SAAS,GAAG,IAAIC,MAAM,CAAC,GAAG,CAAC;AAE/BC,MAAM,CAACC,OAAO,GAAG,UAAUC,IAAI,EAAE;EAC/B,IAAIC,MAAM,GAAGD,IAAI,GAAGA,IAAI,CAACC,MAAM,GAAG,KAAK;EACvC,IAAIC,IAAI,GAAG,CAAC,CAAC;EAEbA,IAAI,CAACC,MAAM,GAAG,UAAUC,IAAI,EAAEC,GAAG,EAAEC,MAAM,EAAE;IACzC,IAAI,CAACF,IAAI,EAAEA,IAAI,GAAG,CAAC,CAAC;IACpB,IAAI,CAACE,MAAM,EAAEA,MAAM,GAAG,CAAC;IACvB,IAAI,CAACD,GAAG,EAAEA,GAAG,GAAG,IAAIR,MAAM,CAACK,IAAI,CAACK,cAAc,CAACH,IAAI,CAAC,GAAGE,MAAM,CAAC;IAE9D,IAAIE,SAAS,GAAGF,MAAM;IACtB,IAAIG,IAAI,GAAGC,MAAM,CAACD,IAAI,CAACL,IAAI,CAAC;IAE5B,IAAIK,IAAI,CAACE,MAAM,KAAK,CAAC,EAAE;MACrBN,GAAG,CAACC,MAAM,CAAC,GAAG,CAAC;MACfA,MAAM,EAAE;IACV;IAEAG,IAAI,CAACG,OAAO,CAAC,UAAUC,GAAG,EAAE;MAC1B,IAAIC,GAAG,GAAGV,IAAI,CAACS,GAAG,CAAC;MACnB,IAAIL,SAAS,GAAGF,MAAM;MACtBA,MAAM,EAAE;MAER,IAAIQ,GAAG,KAAK,IAAI,EAAE;QAChBR,MAAM,IAAID,GAAG,CAACU,KAAK,CAACF,GAAG,EAAEP,MAAM,CAAC;MAClC,CAAC,MAAM,IAAIT,MAAM,CAACmB,QAAQ,CAACF,GAAG,CAAC,EAAE;QAC/BR,MAAM,IAAID,GAAG,CAACU,KAAK,CAACF,GAAG,GAAG,GAAG,EAAEP,MAAM,CAAC;QACtC,IAAIW,GAAG,GAAGH,GAAG,CAACH,MAAM;QACpBG,GAAG,CAACI,IAAI,CAACb,GAAG,EAAEC,MAAM,EAAE,CAAC,EAAEW,GAAG,CAAC;QAC7BX,MAAM,IAAIW,GAAG;MACf,CAAC,MAAM;QACLX,MAAM,IAAID,GAAG,CAACU,KAAK,CAACF,GAAG,GAAG,GAAG,GAAGC,GAAG,EAAER,MAAM,CAAC;MAC9C;MAEAD,GAAG,CAACG,SAAS,CAAC,GAAGF,MAAM,GAAGE,SAAS,GAAG,CAAC;IACzC,CAAC,CAAC;IAEFN,IAAI,CAACC,MAAM,CAACgB,KAAK,GAAGb,MAAM,GAAGE,SAAS;IACtC,OAAOH,GAAG;EACZ,CAAC;EAEDH,IAAI,CAACkB,MAAM,GAAG,UAAUf,GAAG,EAAEC,MAAM,EAAEW,GAAG,EAAE;IACxC,IAAI,CAACX,MAAM,EAAEA,MAAM,GAAG,CAAC;IACvB,IAAI,CAACe,MAAM,CAACC,QAAQ,CAACL,GAAG,CAAC,EAAEA,GAAG,GAAGZ,GAAG,CAACM,MAAM;IAC3C,IAAIP,IAAI,GAAG,CAAC,CAAC;IACb,IAAII,SAAS,GAAGF,MAAM;IAEtB,OAAOA,MAAM,GAAGW,GAAG,EAAE;MACnB,IAAIM,CAAC,GAAGC,WAAW,CAACnB,GAAG,EAAEC,MAAM,CAAC;MAChC,IAAImB,CAAC,GAAG/B,QAAQ,CAAC6B,CAAC,EAAE3B,SAAS,CAAC;MAC9BU,MAAM,IAAIkB,WAAW,CAACL,KAAK;MAE3B,IAAII,CAAC,CAACZ,MAAM,KAAK,CAAC,EAAE,SAAQ,CAAC;MAC7B,IAAIc,CAAC,KAAK,CAAC,CAAC,EAAErB,IAAI,CAACmB,CAAC,CAACG,QAAQ,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC,CAAC,GAAG,IAAI,MAChD,IAAIF,CAAC,KAAK,CAAC,EAAE,SAAQ,CAAC;MAAA,KACtB;QACH,IAAIZ,GAAG,GAAGU,CAAC,CAACK,KAAK,CAAC,CAAC,EAAEH,CAAC,CAAC,CAACC,QAAQ,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC;QAChD,IAAId,GAAG,IAAIT,IAAI,EAAE,SAAQ,CAAC;QAC1BA,IAAI,CAACS,GAAG,CAAC,GAAGZ,MAAM,GAAGsB,CAAC,CAACK,KAAK,CAACH,CAAC,GAAG,CAAC,CAAC,GAAGF,CAAC,CAACK,KAAK,CAACH,CAAC,GAAG,CAAC,CAAC,CAACC,QAAQ,CAAC,CAAC;MACjE;IACF;IAEAxB,IAAI,CAACkB,MAAM,CAACD,KAAK,GAAGb,MAAM,GAAGE,SAAS;IACtC,OAAOJ,IAAI;EACb,CAAC;EAEDF,IAAI,CAACK,cAAc,GAAG,UAAUH,IAAI,EAAE;IACpC,IAAI,CAACA,IAAI,EAAE,OAAO,CAAC,EAAC;IACpB,IAAIK,IAAI,GAAGC,MAAM,CAACD,IAAI,CAACL,IAAI,CAAC;IAC5B,IAAIK,IAAI,CAACE,MAAM,KAAK,CAAC,EAAE,OAAO,CAAC,EAAC;IAChC,OAAOF,IAAI,CAACoB,MAAM,CAAC,UAAUC,KAAK,EAAEjB,GAAG,EAAE;MACvC,IAAIC,GAAG,GAAGV,IAAI,CAACS,GAAG,CAAC;MACnBiB,KAAK,IAAIjC,MAAM,CAACkC,UAAU,CAAClB,GAAG,CAAC,GAAG,CAAC,EAAC;MACpC,IAAIhB,MAAM,CAACmB,QAAQ,CAACF,GAAG,CAAC,EAAEgB,KAAK,IAAIhB,GAAG,CAACH,MAAM,GAAG,CAAC,EAAC;MAAA,KAC7C,IAAIG,GAAG,KAAK,IAAI,EAAEgB,KAAK,IAAIjC,MAAM,CAACkC,UAAU,CAACC,MAAM,CAAClB,GAAG,CAAC,CAAC,GAAG,CAAC,EAAC;MACnE,OAAOgB,KAAK;IACd,CAAC,EAAE,CAAC,CAAC;EACP,CAAC;EAED,OAAO5B,IAAI;AACb,CAAC;AAED,SAASsB,WAAWA,CAAEnB,GAAG,EAAEC,MAAM,EAAE;EACjC,IAAIW,GAAG,GAAGZ,GAAG,CAACC,MAAM,CAAC;EACrB,IAAI2B,EAAE,GAAG3B,MAAM,GAAG,CAAC,GAAGW,GAAG;EACzB,IAAIM,CAAC,GAAGlB,GAAG,CAACuB,KAAK,CAACtB,MAAM,GAAG,CAAC,EAAE2B,EAAE,GAAG5B,GAAG,CAACM,MAAM,GAAGN,GAAG,CAACM,MAAM,GAAGsB,EAAE,CAAC;EAChET,WAAW,CAACL,KAAK,GAAGF,GAAG,GAAG,CAAC;EAC3B,OAAOM,CAAC;AACV","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}